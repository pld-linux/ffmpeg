--- ffmpeg-2.8.5/libavcodec/libutvideoenc.cpp.orig	2016-01-17 15:47:01.790581181 +0100
+++ ffmpeg-2.8.5/libavcodec/libutvideoenc.cpp	2016-01-17 20:53:18.793143645 +0100
@@ -38,12 +38,11 @@
 {
     UtVideoContext *utv = (UtVideoContext *)avctx->priv_data;
     UtVideoExtra *info;
-    uint32_t flags, in_format;
+    uint32_t flags;
     int ret;
 
     switch (avctx->pix_fmt) {
     case AV_PIX_FMT_YUV420P:
-        in_format = UTVF_YV12;
         avctx->bits_per_coded_sample = 12;
         if (avctx->colorspace == AVCOL_SPC_BT709)
             avctx->codec_tag = MKTAG('U', 'L', 'H', '0');
@@ -51,7 +50,6 @@
             avctx->codec_tag = MKTAG('U', 'L', 'Y', '0');
         break;
     case AV_PIX_FMT_YUYV422:
-        in_format = UTVF_YUYV;
         avctx->bits_per_coded_sample = 16;
         if (avctx->colorspace == AVCOL_SPC_BT709)
             avctx->codec_tag = MKTAG('U', 'L', 'H', '2');
@@ -59,12 +57,10 @@
             avctx->codec_tag = MKTAG('U', 'L', 'Y', '2');
         break;
     case AV_PIX_FMT_BGR24:
-        in_format = UTVF_NFCC_BGR_BU;
         avctx->bits_per_coded_sample = 24;
         avctx->codec_tag = MKTAG('U', 'L', 'R', 'G');
         break;
     case AV_PIX_FMT_RGB32:
-        in_format = UTVF_NFCC_BGRA_BU;
         avctx->bits_per_coded_sample = 32;
         avctx->codec_tag = MKTAG('U', 'L', 'R', 'A');
         break;
@@ -113,16 +109,14 @@
      * Create a Ut Video instance. Since the function wants
      * an "interface name" string, pass it the name of the lib.
      */
-    utv->codec = CCodec::CreateInstance(UNFCC(avctx->codec_tag), "libavcodec");
+    utv->codec = CCodec::CreateInstance(htobe32(avctx->codec_tag), "libavcodec");
 
     /* Initialize encoder */
-    utv->codec->EncodeBegin(in_format, avctx->width, avctx->height,
-                            CBGROSSWIDTH_WINDOWS);
+    utv->codec->EncodeBegin(avctx->width, avctx->height);
 
     /* Get extradata from encoder */
     avctx->extradata_size = utv->codec->EncodeGetExtraDataSize();
-    utv->codec->EncodeGetExtraData(info, avctx->extradata_size, in_format,
-                                   avctx->width, avctx->height,
-                                   CBGROSSWIDTH_WINDOWS);
+    utv->codec->EncodeGetExtraData(info, avctx->extradata_size,
+                                   avctx->width, avctx->height);
     avctx->extradata = (uint8_t *)info;
 
@@ -140,6 +134,7 @@
     bool keyframe;
     uint8_t *y, *u, *v;
     uint8_t *dst;
+    uint32_t in_format;
 
     /* Alloc buffer */
     if ((ret = ff_alloc_packet2(avctx, pkt, utv->buf_size, 0)) < 0)
@@ -150,6 +145,7 @@
     /* Move input if needed data into Ut Video friendly buffer */
     switch (avctx->pix_fmt) {
     case AV_PIX_FMT_YUV420P:
+        in_format = UTVF_YV12;
         y = utv->buffer;
         u = y + w * h;
         v = u + w * h / 4;
@@ -165,12 +161,14 @@
         }
         break;
     case AV_PIX_FMT_YUYV422:
+        in_format = UTVF_YUYV;
         for (i = 0; i < h; i++)
             memcpy(utv->buffer + i * (w << 1),
                    pic->data[0] + i * pic->linesize[0], w << 1);
         break;
     case AV_PIX_FMT_BGR24:
     case AV_PIX_FMT_RGB32:
+        in_format = avctx->pix_fmt == AV_PIX_FMT_BGR24 ? UTVF_NFCC_BGR_BU : UTVF_NFCC_BGRA_BU;
         /* Ut Video takes bottom-up BGR */
         rgb_size = avctx->pix_fmt == AV_PIX_FMT_BGR24 ? 3 : 4;
         for (i = 0; i < h; i++)
@@ -183,7 +181,7 @@
     }
 
     /* Encode frame */
-    pkt->size = utv->codec->EncodeFrame(dst, &keyframe, utv->buffer);
+    pkt->size = utv->codec->EncodeFrame(dst, &keyframe, utv->buffer, in_format, CBGROSSWIDTH_WINDOWS);
 
     if (!pkt->size) {
         av_log(avctx, AV_LOG_ERROR, "EncodeFrame failed!\n");
--- ffmpeg-2.8.5/libavcodec/libutvideodec.cpp.orig	2016-01-17 15:47:01.790581181 +0100
+++ ffmpeg-2.8.5/libavcodec/libutvideodec.cpp	2016-01-17 20:39:38.713177720 +0100
@@ -36,7 +36,6 @@
 {
     UtVideoContext *utv = (UtVideoContext *)avctx->priv_data;
     UtVideoExtra info;
-    int format;
     int begin_ret;
 
     if (avctx->extradata_size != 16 && avctx->extradata_size != 8 ) {
@@ -56,34 +55,27 @@
     case MKTAG('U', 'L', 'H', '0'):
         avctx->pix_fmt = AV_PIX_FMT_YUV420P;
         avctx->colorspace = AVCOL_SPC_BT709;
-        format = UTVF_YV12;
         break;
     case MKTAG('U', 'L', 'H', '2'):
         avctx->pix_fmt = AV_PIX_FMT_YUYV422;
         avctx->colorspace = AVCOL_SPC_BT709;
-        format = UTVF_YUY2;
         break;
 #endif
     case MKTAG('U', 'L', 'Y', '0'):
         avctx->pix_fmt = AV_PIX_FMT_YUV420P;
-        format = UTVF_YV12;
         break;
     case MKTAG('U', 'L', 'Y', '2'):
         avctx->pix_fmt = AV_PIX_FMT_YUYV422;
-        format = UTVF_YUY2;
         break;
     case MKTAG('U', 'L', 'R', 'G'):
         avctx->pix_fmt = AV_PIX_FMT_BGR24;
-        format = UTVF_NFCC_BGR_BU;
         break;
     case MKTAG('U', 'L', 'R', 'A'):
         avctx->pix_fmt = AV_PIX_FMT_RGB32;
-        format = UTVF_NFCC_BGRA_BU;
         break;
 #ifdef UTVF_UQY2
     case MKTAG('U', 'Q', 'Y', '2'):
         avctx->pix_fmt = AV_PIX_FMT_YUV422P10;
-        format = UTVF_v210;
         break;
 #endif
     default:
@@ -95,7 +87,7 @@
     /* Only allocate the buffer once */
     utv->buf_size = avpicture_get_size(avctx->pix_fmt, avctx->width, avctx->height);
 #ifdef UTVF_UQY2
-    if (format == UTVF_v210)
+    if (avctx->pix_fmt == AV_PIX_FMT_YUV422P10)
         utv->buf_size += avctx->height * ((avctx->width + 47) / 48) * 128; // the linesize used by the decoder, this does not seem to be exported
 #endif
     utv->buffer = (uint8_t *)av_malloc(utv->buf_size * sizeof(uint8_t));
@@ -121,11 +113,10 @@
      * Create a Ut Video instance. Since the function wants
      * an "interface name" string, pass it the name of the lib.
      */
-    utv->codec = CCodec::CreateInstance(UNFCC(avctx->codec_tag), "libavcodec");
+    utv->codec = CCodec::CreateInstance(htobe32(avctx->codec_tag), "libavcodec");
 
     /* Initialize Decoding */
-    begin_ret = utv->codec->DecodeBegin(format, avctx->width, avctx->height,
-                            CBGROSSWIDTH_WINDOWS, &info, sizeof(UtVideoExtra));
+    begin_ret = utv->codec->DecodeBegin(avctx->width, avctx->height, &info, sizeof(UtVideoExtra));
 
     /* Check to see if the decoder initlized properly */
     if (begin_ret != 0) {
@@ -143,13 +134,34 @@
     UtVideoContext *utv = (UtVideoContext *)avctx->priv_data;
     AVFrame *pic = avctx->coded_frame;
     int w = avctx->width, h = avctx->height;
+    int format;
 
     /* Set flags */
     pic->pict_type = AV_PICTURE_TYPE_I;
     pic->key_frame = 1;
 
+    switch (avctx->pix_fmt) {
+    case AV_PIX_FMT_YUV420P:
+        format = UTVF_YV12;
+        break;
+    case AV_PIX_FMT_YUYV422:
+        format = UTVF_YUY2;
+        break;
+    case AV_PIX_FMT_BGR24:
+        format = UTVF_NFCC_BGR_BU;
+        break;
+    case AV_PIX_FMT_RGB32:
+        format = UTVF_NFCC_BGRA_BU;
+        break;
+#ifdef UTVF_UQY2
+    case AV_PIX_FMT_YUV422P10:
+        format = UTVF_v210;
+        break;
+#endif
+    }
+
     /* Decode the frame */
-    utv->codec->DecodeFrame(utv->buffer, avpkt->data, true);
+    utv->codec->DecodeFrame(utv->buffer, avpkt->data, format, CBGROSSWIDTH_WINDOWS);
 
     /* Set the output data depending on the colorspace */
     switch (avctx->pix_fmt) {
